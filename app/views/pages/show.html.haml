- content_for :title do
  =@page.title
.form
  = form_for @page.becomes(Page) do
    = submit_tag "Read Now"
    = submit_tag "Read Later"
    = submit_tag "Rebuild from Raw HTML"
    = submit_tag "Remove Downloads"
    = submit_tag "Remove Duplicate Tags" unless @page.parts.blank?
    = submit_tag "Rebuild Meta"
    = submit_tag "Toggle #{Page::OTHER}"
    = submit_tag "Toggle #{Page::TT}"
    = submit_tag "Toggle End Notes"
    = submit_tag "Make Single" if @page.parent
    = submit_tag "Uncollect" unless @page.parts.blank?
-if @page.parent
  .parent
    Parent:
    = link_to @page.parent.title, page_path(@page.parent)
    (#{@page.parent.type})
-if @page.next_part
  .part
    Next:
    = link_to @page.next_part.title, page_path(@page.next_part)
    (#{@page.next_part.type})
.page
  .title
    =h @page.title
    (#{@page.type})
  .views
    = link_to "Rate", rate_path(@page)
    = link_to "ePub", download_url_for_page(@page, ".epub")
    = link_to "HTML", download_url_for_page(@page, ".html")
    = link_to "Text", download_url_for_page(@page, ".read") if @page.parts.blank?
    = link_to "Original", @page.url unless @page.url.blank?
    .content
      = link_to "Refetch", refetch_path(@page)
      = link_to "Add Part", edit_part_path(@page, add: "part")
      = link_to "Add Parent", edit_part_path(@page, add: "parent")
      - if @page.parts.blank?
        = link_to "Edit Scrubbed HTML", edit_html_path(@page, format: "scrubbed")
        = link_to "Edit Raw HTML", edit_html_path(@page)
      = link_to "Scrub", scrub_path(@page)
    .meta
      = link_to "Title", edit_part_path(@page, add: "title")
      = link_to "My Notes", edit_my_note_path(@page)
      = link_to "Notes", edit_note_path(@page)
      = link_to "Tags", tag_path(@page)
  -Tag.types.each do |type|
    .div{class: "#{type.downcase.pluralize}"}
      -@page.tags.send(type.downcase.pluralize).by_name.each do |tag|
        =link_to_tag tag, tag.base_name
  .stars= @page.star_string
  .size
    =@page.size_string
  .last_read=@page.last_read_string
  .my_notes=raw @page.formatted_my_notes
  .notes
    =raw @page.medium_notes
    =link_to "full notes", note_path(@page.id) if @page.notes.present? && @page.notes.length > Page::MEDIUM_LENGTH
  .end_notes=raw @page.formatted_end_notes
-unless @page.parts.blank?
  -last = @count + Page::LIMIT
  -Rails.logger.debug "DEBUG: page parts #{@count} to #{last} of #{@page.parts.size}"
  .parts
    - @page.parts.limit(last)[@count..-1].each_with_index do |part, index|
      .part{:id => "position_#{index+1}"}
        = part.title_prefix
        = link_to h(part.title), page_path(part)
        = part.title_suffix
        = link_to "Rate", rate_path(part)
        = link_to "EPUB", download_url_for_page(part, ".epub")
        = link_to "HTML", download_url_for_page(part, ".html")
        = link_to "Text", download_url_for_page(part, ".read") if part.parts.blank?
        = link_to "Original", part.url unless part.url.blank?
        %span.my_notes=part.short_my_notes
        %span.notes=part.short_notes
        %span.end_notes=part.short_end_notes
  .form
    = form_for @page.becomes(Page) do
      = hidden_field_tag :count, @count
      = submit_tag "First Parts" if @count > 0
      = submit_tag "Next Parts" if @page.parts.size > last
      = submit_tag "Middle Parts" if @count > 0 || @page.parts.size > last
      = submit_tag "Previous Parts" if @count > 0
      = submit_tag "Last Parts" if @page.parts.size > last
